use serde_json::Value;
use url::form_urlencoded::byte_serialize;

/// Formats a JSON string
///
/// JSON strings generated by AI are not always reliable and valid. The main issue is that they are often wrapped in ```json and ```,
/// which is actually Markdown format. These wrappers need to be removed, otherwise the string cannot be parsed as valid JSON. Another common issue is
/// the inclusion of newlines, which also makes the string invalid.
///
/// # Arguments
/// * `jstr` - JSON string to format
///
/// # Returns
/// The formatted JSON string
pub fn format_json_str(jstr: &str) -> String {
    let mut formatted = jstr
        .trim()
        .trim_start_matches("```json")
        .trim_start_matches(|c: char| c == '`' || c.is_whitespace())
        .trim_end_matches(|c: char| c == '`' || c.is_whitespace())
        .replace('\n', "")
        .replace('\r', "")
        .replace("    ", "")
        .replace('\t', "");
    if formatted.ends_with('}') && !formatted.starts_with('{') {
        formatted = format!("{{{formatted}");
    } else if formatted.starts_with('{') && !formatted.ends_with('}') {
        formatted = format!("{formatted}}}");
    }

    formatted
}

/// URL encode a string
///
/// # Arguments
/// * `s` - The string to encode
///
/// # Returns
/// * `String` - The encoded string
pub fn urlencode(s: &str) -> String {
    byte_serialize(s.as_bytes()).collect::<String>()
}

/// URL encode a JSON value
///
/// # Arguments
/// * `s` - The JSON value to encode
///
/// # Returns
/// * `String` - The encoded string
pub fn urlencodes(s: &Value) -> String {
    match s {
        Value::String(s) => urlencode(s),
        Value::Number(n) => n.to_string(),
        Value::Bool(b) => b.to_string(),
        Value::Array(arr) => arr.iter().map(urlencodes).collect::<Vec<_>>().join(","),
        Value::Object(obj) => obj
            .iter()
            .map(|(k, v)| format!("{}={}", urlencode(k), urlencodes(v)))
            .collect::<Vec<_>>()
            .join("&"),
        Value::Null => "".to_string(),
    }
}
